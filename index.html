<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raccoon Rascal: The Great Trash Heist</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #87CEEB; }
        #ui-layer { position: absolute; top: 20px; left: 20px; color: white; text-shadow: 2px 2px 0px rgba(0,0,0,0.5); pointer-events: none; }
        h1 { margin: 0; font-size: 2rem; color: #ffd700; -webkit-text-stroke: 1px #d35400; }
        #score-board { font-size: 1.5rem; font-weight: bold; margin-top: 10px; }
        #controls-hint { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: white; font-weight: bold; text-shadow: 1px 1px 2px black; text-align: center; background: rgba(0,0,0,0.3); padding: 10px 20px; border-radius: 20px; }
        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; color: white; text-align: center; }
        #win-screen { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255, 255, 255, 0.9); padding: 40px; border-radius: 20px; text-align: center; display: none; box-shadow: 0 10px 30px rgba(0,0,0,0.3); color: #333; z-index: 101; }
        #win-screen h2 { color: #27ae60; font-size: 3rem; margin: 0 0 20px 0; }
        button { background: #e67e22; border: none; padding: 15px 30px; color: white; font-size: 1.2rem; border-radius: 50px; cursor: pointer; font-weight: bold; transition: transform 0.2s; pointer-events: auto; }
        button:hover { transform: scale(1.05); background: #d35400; }
        #squeak-bubble { position: fixed; left: 50%; top: 55%; transform: translate(-50%, -50%); background: white; color: black; padding: 8px 14px; border-radius: 18px; font-weight: bold; font-size: 14px; opacity: 0; pointer-events: none; transition: opacity 0.15s, transform 0.4s; box-shadow: 0 4px 12px rgba(0,0,0,0.25); }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1>Raccoon Rascal</h1>
        <p style="margin-bottom: 25px;">The Great Trash Heist</p>
        <button id="start-btn">Start Game</button>
    </div>

    <div id="ui-layer">
        <h1>Raccoon Rascal</h1>
        <div id="score-board">Trash Collected: <span id="score">0</span> / <span id="total">0</span></div>
    </div>

    <div id="controls-hint">
        WASD to Move &bull; SHIFT to Sprint &bull; F to Squeak (Rhythm!) &bull; E to Gamble
    </div>

    <div id="squeak-bubble">*squeak!*</div>

    <div id="win-screen">
        <h2>Trash Master!</h2>
        <p>You cleaned up the whole park!</p>
        <button onclick="location.reload()">Play Again</button>
    </div>

    <script>
        // --- Game Constants ---
        const WORLD_SIZE = 200;
        const TRASH_COUNT = 15;
        const COLORS = {
            raccoonGrey: 0x7f8c8d, raccoonDark: 0x2c3e50, raccoonWhite: 0xecf0f1,
            grass: 0x7bc043, sky: 0x87CEEB, wood: 0x8e44ad
        };

        // --- Global Variables ---
        let scene, camera, renderer;
        let raccoon, tail, headGroup;
        let trashItems = [];
        let trees = [];
        let particles = [];
        let score = 0;
        let isGameActive = false;
        let listener;
        let radioSound;
        let radioMesh;
        
        // Rhythm / Combo Variables
        let bpm = 98;
        let beatInterval = 0.6122;
        let lastBeatTime = 0;
        let combo = 0;
        let comboActive = false;
        let comboTimer = 0;
        let comboDuration = 4;
        let comboMultiplier = 2;
        let isDancing = false;
        let danceSpeed = 6;
        let danceIntensity = 0;
        let maxDanceIntensity = 3;

        // Audio Objects
        let gamblingSound = new Audio("gambling-music.mp3");
        let squeakSound = new Audio("squeak.wav");
        squeakSound.volume = 0.8;
        let lastSqueakTime = 0;
        let collectSound = new Audio("collect.wav");
        collectSound.volume = 0.7;

        // Input state
        const keys = { w: false, a: false, s: false, d: false, Shift: false };
        
        // Physics/Movement
        const playerSpeed = 0.25;
        const sprintMultiplier = 1.6;
        const turnSpeed = 0.06;
        let currentRotVel = 0;
        let time = 0;

        // Gambling State
        let nearRadio = false;
        let gamblingActive = false;

        function playCollectSound() {
            collectSound.currentTime = 0;
            collectSound.play().catch(e => console.log("Audio play failed (interaction needed)"));
        }

        function checkRadioProximity() {
            if(!radioMesh || !raccoon) return;
            const dist = raccoon.position.distanceTo(radioMesh.position);
            nearRadio = dist < 5; // Increased range slightly
            if (nearRadio && !gamblingActive) {
                showGamblePrompt();
            } else {
                hideGamblePrompt();
            }
        }

        function showGamblePrompt() {
            let prompt = document.getElementById("gamble-prompt");
            if (!prompt) {
                prompt = document.createElement("div");
                prompt.id = "gamble-prompt";
                prompt.style.position = "absolute";
                prompt.style.bottom = "100px";
                prompt.style.left = "50%";
                prompt.style.transform = "translateX(-50%)";
                prompt.style.background = "rgba(0,0,0,0.7)";
                prompt.style.color = "white";
                prompt.style.padding = "15px 25px";
                prompt.style.borderRadius = "15px";
                prompt.style.fontWeight = "bold";
                prompt.style.textAlign = "center";
                prompt.innerText = "Press E to tune the radio to the Gambling Station!";
                document.body.appendChild(prompt);
            }
        }

        function hideGamblePrompt() {
            const prompt = document.getElementById("gamble-prompt");
            if (prompt) prompt.remove();
        }

        window.addEventListener("keydown", (e) => {
            if (!nearRadio || gamblingActive) return;
            if (e.key.toLowerCase() === "e") {
                openGamblingStation();
            }
        });

        function openGamblingStation() {
            gamblingActive = true;
            if (radioSound && radioSound.isPlaying) radioSound.pause();
            if (gamblingSound) { gamblingSound.currentTime = 0; gamblingSound.play().catch(e=>{}); }

            const modal = document.createElement("div");
            modal.id = "gamble-modal";
            modal.style.position = "absolute";
            modal.style.top = "50%";
            modal.style.left = "50%";
            modal.style.transform = "translate(-50%, -50%)";
            modal.style.background = "rgba(255,255,255,0.95)";
            modal.style.padding = "30px";
            modal.style.borderRadius = "20px";
            modal.style.textAlign = "center";
            modal.style.zIndex = 200;
            modal.innerHTML = `
                <h2>Master Raccoon</h2>
                <p>"Ah, you want to gamble your hard-earned trash points, eh?"</p>
                <button id="red-btn">Red</button>
                <button id="black-btn">Black</button>
                <button id="cancel-btn">Cancel</button>
            `;
            document.body.appendChild(modal);

            document.getElementById("red-btn").onclick = () => resolveGamble("red");
            document.getElementById("black-btn").onclick = () => resolveGamble("black");
            document.getElementById("cancel-btn").onclick = () => closeGambleModal();
        }

        function closeGambleModal() {
            gamblingActive = false;
            const modal = document.getElementById("gamble-modal");
            if (modal) modal.remove();
            if (gamblingSound) gamblingSound.pause();
            if (radioSound && !radioSound.isPlaying) radioSound.play().catch(e=>{});
        }

        function resolveGamble(choice) {
            const outcome = Math.random() < 0.5 ? "red" : "black";
            let resultText = "";
            if (choice === outcome) {
                score *= 2;
                resultText = `You won! Your points are now ${score}`;
            } else {
                score = Math.floor(score / 2);
                resultText = `You lost! Your points are now ${score}`;
            }
            document.getElementById("score").innerText = score;
            alert(resultText);
            closeGambleModal();
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.sky);
            scene.fog = new THREE.Fog(COLORS.sky, 20, 100);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, -20);
            camera.lookAt(0, 0, 0);

            listener = new THREE.AudioListener();
            camera.add(listener);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 80, 50);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -WORLD_SIZE/2;
            dirLight.shadow.camera.right = WORLD_SIZE/2;
            dirLight.shadow.camera.top = WORLD_SIZE/2;
            dirLight.shadow.camera.bottom = -WORLD_SIZE/2;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            createGround();
            createEnvironment();
            createRaccoon();
            createRadio();
            spawnTrash(TRASH_COUNT);

            document.getElementById('total').innerText = TRASH_COUNT;

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (e) => handleKey(e, true));
            window.addEventListener('keyup', (e) => handleKey(e, false));
            window.addEventListener('keydown', (e) => {
                if (!isGameActive) return;
                if (e.key.toLowerCase() === "f") {
                    playSqueak();
                }
            });

            document.getElementById('start-btn').onclick = () => {
                isGameActive = true;
                document.getElementById('start-screen').style.display = 'none';
                if (listener && listener.context.state === "suspended") {
                    listener.context.resume();
                }
            };

            animate();
        }

        function createGround() {
            const geometry = new THREE.CircleGeometry(WORLD_SIZE / 2, 64);
            const material = new THREE.MeshStandardMaterial({ color: COLORS.grass, roughness: 1, flatShading: true });
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function createRaccoon() {
            raccoon = new THREE.Group();
            const greyMat = new THREE.MeshStandardMaterial({ color: COLORS.raccoonGrey });
            const darkMat = new THREE.MeshStandardMaterial({ color: COLORS.raccoonDark });
            const whiteMat = new THREE.MeshStandardMaterial({ color: COLORS.raccoonWhite });
            const blackMat = new THREE.MeshStandardMaterial({ color: 0x000000 });

            const bodyGeo = new THREE.CylinderGeometry(1.2, 1.5, 3.5, 12);
            const body = new THREE.Mesh(bodyGeo, greyMat);
            body.rotation.x = Math.PI / 2;
            body.position.y = 1.5;
            body.castShadow = true;
            raccoon.add(body);

            headGroup = new THREE.Group();
            headGroup.position.set(0, 2.5, 2);
            raccoon.add(headGroup);

            const headGeo = new THREE.DodecahedronGeometry(1.4);
            const head = new THREE.Mesh(headGeo, greyMat);
            head.castShadow = true;
            headGroup.add(head);

            const snoutGeo = new THREE.ConeGeometry(0.8, 1.2, 12);
            const snout = new THREE.Mesh(snoutGeo, whiteMat);
            snout.rotation.x = Math.PI / 2;
            snout.position.z = 1;
            snout.castShadow = true;
            headGroup.add(snout);

            const noseGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const nose = new THREE.Mesh(noseGeo, blackMat);
            nose.position.z = 1.6;
            headGroup.add(nose);

            const maskGeo = new THREE.BoxGeometry(2.2, 0.6, 0.5);
            const mask = new THREE.Mesh(maskGeo, darkMat);
            mask.position.set(0, 0.2, 0.8);
            headGroup.add(mask);

            const eyeGeo = new THREE.SphereGeometry(0.2, 8, 8);
            const eyeL = new THREE.Mesh(eyeGeo, whiteMat);
            const eyeR = new THREE.Mesh(eyeGeo, whiteMat);
            eyeL.position.set(-0.6, 0.3, 1.1);
            eyeR.position.set(0.6, 0.3, 1.1);
            headGroup.add(eyeL);
            headGroup.add(eyeR);

            const earGeo = new THREE.ConeGeometry(0.6, 1, 4);
            const earL = new THREE.Mesh(earGeo, darkMat);
            earL.position.set(-0.8, 1.2, 0);
            earL.rotation.z = 0.5;
            headGroup.add(earL);

            const earR = new THREE.Mesh(earGeo, darkMat);
            earR.position.set(0.8, 1.2, 0);
            earR.rotation.z = -0.5;
            headGroup.add(earR);

            tail = new THREE.Group();
            tail.position.set(0, 1.2, -1.8);
            raccoon.add(tail);

            const tailSegGeo = new THREE.CylinderGeometry(0.5, 0.8, 3, 12);
            const tailMesh = new THREE.Mesh(tailSegGeo, greyMat);
            tailMesh.rotation.x = -Math.PI / 4;
            tailMesh.position.y = 0.5;
            tailMesh.position.z = -1;
            tailMesh.castShadow = true;
            tail.add(tailMesh);

            for(let i=0; i<3; i++) {
                const stripeGeo = new THREE.TorusGeometry(0.6 + (i*0.05), 0.1, 8, 16);
                const stripe = new THREE.Mesh(stripeGeo, darkMat);
                stripe.rotation.x = Math.PI / 4;
                stripe.position.set(0, 0.5 + (i*0.6) - 0.5, -1 - (i*0.6));
                tail.add(stripe);
            }

            const legGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8);
            const positions = [{x: -0.8, z: 1, name: 'fl'}, {x: 0.8, z: 1, name: 'fr'}, {x: -0.8, z: -1, name: 'bl'}, {x: 0.8, z: -1, name: 'br'}];
            positions.forEach(pos => {
                const leg = new THREE.Mesh(legGeo, darkMat);
                leg.position.set(pos.x, 0.6, pos.z);
                leg.name = pos.name;
                raccoon.add(leg);
            });
            scene.add(raccoon);
        }

        function createEnvironment() {
            for(let i = 0; i < 40; i++) {
                const tree = new THREE.Group();
                const trunkGeo = new THREE.CylinderGeometry(0.5, 0.8, 2, 8);
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = 1;
                trunk.castShadow = true;
                tree.add(trunk);
                const leavesGeo = new THREE.ConeGeometry(2.5, 5, 8);
                const leavesMat = new THREE.MeshStandardMaterial({ color: 0x27ae60 });
                const leaves = new THREE.Mesh(leavesGeo, leavesMat);
                leaves.position.y = 3.5;
                leaves.castShadow = true;
                tree.add(leaves);
                let x = (Math.random() - 0.5) * WORLD_SIZE * 0.9;
                let z = (Math.random() - 0.5) * WORLD_SIZE * 0.9;
                if (Math.abs(x) < 5 && Math.abs(z) < 5) x += 10;
                tree.position.set(x, 0, z);
                const scale = 0.8 + Math.random() * 0.5;
                tree.scale.set(scale, scale, scale);
                scene.add(tree);
                trees.push(tree);
            }
        }

        function createRadio() {
            // simple radio mesh
            const geo = new THREE.BoxGeometry(2, 1, 1);
            const mat = new THREE.MeshStandardMaterial({ color: 0x444444 });
            radioMesh = new THREE.Mesh(geo, mat);
            radioMesh.position.set(8, 0.5, 8);
            radioMesh.castShadow = true;
            scene.add(radioMesh);

            // positional audio
            radioSound = new THREE.PositionalAudio(listener);
            
            // --- FIX 2: Define audioLoader ---
            const audioLoader = new THREE.AudioLoader(); 

            // Load main background music
            audioLoader.load("bg-music.mp3", (buffer) => {
                radioSound.setBuffer(buffer);
                radioSound.setLoop(true);
                radioSound.setVolume(1.0);
                radioSound.setRefDistance(5);
                radioSound.setMaxDistance(60);
                radioSound.setRolloffFactor(1.5);
                radioSound.play();
            });

            // --- FIX 1: Add to mesh INSIDE the function ---
            radioMesh.add(radioSound); 
        }

        function spawnTrash(count) {
            const trashTypes = [
                { color: 0xe74c3c, geo: new THREE.CylinderGeometry(0.25, 0.25, 0.8, 10), offsetY: 0.25 },
                { color: 0xf1c40f, geo: new THREE.BoxGeometry(0.8, 0.2, 0.2), offsetY: 0.1 },
                { color: 0xecf0f1, geo: new THREE.DodecahedronGeometry(0.3), offsetY: 0.3 }
            ];
            for (let i=0; i < count; i++) {
                const type = trashTypes[Math.floor(Math.random() * trashTypes.length)];
                const mat = new THREE.MeshStandardMaterial({ color: type.color });
                const mesh = new THREE.Mesh(type.geo, mat);
                mesh.castShadow = true;
                let x = (Math.random() - 0.5) * (WORLD_SIZE - 10);
                let z = (Math.random() - 0.5) * (WORLD_SIZE - 10);
                mesh.position.set(x, type.offsetY, z);
                mesh.userData = { floatOffset: Math.random() * 100, rotationSpeed: (Math.random() * 0.02) + 0.01, originalY: type.offsetY };
                scene.add(mesh);
                trashItems.push(mesh);
            }
        }

        function createParticleExplosion(pos, color) {
            for(let i=0; i<8; i++) {
                const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const mat = new THREE.MeshBasicMaterial({ color: color });
                const p = new THREE.Mesh(geo, mat);
                p.position.copy(pos);
                const vel = new THREE.Vector3((Math.random() - 0.5) * 0.5, (Math.random() * 0.5) + 0.2, (Math.random() - 0.5) * 0.5);
                scene.add(p);
                particles.push({ mesh: p, vel: vel, life: 60 });
            }
        }

        function handleKey(e, isDown) {
            const state = isDown;
            switch(e.key.toLowerCase()) {
                case 'w': case 'arrowup': keys.w = state; break;
                case 'a': case 'arrowleft': keys.a = state; break;
                case 's': case 'arrowdown': keys.s = state; break;
                case 'd': case 'arrowright': keys.d = state; break;
                case 'shift': keys.Shift = state; break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function checkCollisions() {
            for (let i = trashItems.length - 1; i >= 0; i--) {
                const item = trashItems[i];
                if (raccoon.position.distanceTo(item.position) < 2.5) {
                    playCollectSound();
                    createParticleExplosion(item.position, item.material.color);
                    scene.remove(item);
                    trashItems.splice(i, 1);
                    
                    let points = 1;
                    if (comboActive) points *= comboMultiplier;
                    
                    score += points;
                    document.getElementById('score').innerText = score;
                    
                    if (score >= TRASH_COUNT) gameWin();
                }
            }
        }

        function gameWin() {
            document.getElementById('win-screen').style.display = 'block';
            createParticleExplosion(raccoon.position, 0xffd700);
            if (radioSound && radioSound.isPlaying) {
                radioSound.stop();
            }
        }

        function updateRaccoon() {
            if (!raccoon || !isGameActive) return;
            let moveSpeed = keys.Shift ? playerSpeed * sprintMultiplier : playerSpeed;
            let isMoving = false;
            let targetRotVel = 0;
            if (keys.a) targetRotVel = turnSpeed;
            if (keys.d) targetRotVel = -turnSpeed;
            currentRotVel = THREE.MathUtils.lerp(currentRotVel, targetRotVel, 0.1);
            raccoon.rotation.y += currentRotVel;
            const forward = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), raccoon.rotation.y);
            if (keys.w) { raccoon.position.add(forward.multiplyScalar(moveSpeed)); isMoving = true; }
            if (keys.s) { raccoon.position.add(forward.multiplyScalar(-moveSpeed * 0.6)); isMoving = true; }
            const limit = WORLD_SIZE / 2 - 2;
            raccoon.position.x = Math.max(-limit, Math.min(limit, raccoon.position.x));
            raccoon.position.z = Math.max(-limit, Math.min(limit, raccoon.position.z));
            if (isMoving) {
                const speed = keys.Shift ? 18 : 10;
                raccoon.children.forEach(child => {
                    if (child.name === 'fl' || child.name === 'br') child.rotation.x = Math.sin(time * speed) * 0.5;
                    else if (child.name === 'fr' || child.name === 'bl') child.rotation.x = Math.cos(time * speed) * 0.5;
                });
                const bobOffset = Math.sin(time * speed * 2) * 0.25; 
                raccoon.children[0].position.y = 1.5 + bobOffset;
                if (headGroup) headGroup.position.y = 2.5 + bobOffset;
                if (tail) { tail.position.y = 1.2 + bobOffset; tail.rotation.y = Math.sin(time * 15) * 0.5; }
            } else {
                raccoon.children.forEach(child => { if (child.name && child.name.length === 2) child.rotation.x = THREE.MathUtils.lerp(child.rotation.x, 0, 0.1); });
                raccoon.children[0].position.y = THREE.MathUtils.lerp(raccoon.children[0].position.y, 1.5, 0.1);
                if (headGroup) headGroup.position.y = THREE.MathUtils.lerp(headGroup.position.y, 2.5, 0.1);
                if (tail) { tail.position.y = THREE.MathUtils.lerp(tail.position.y, 1.2, 0.1); tail.rotation.y = THREE.MathUtils.lerp(tail.rotation.y, 0, 0.1); }
            }
        }

        function updateCamera() {
            if (!raccoon) return;
            const relativeOffset = new THREE.Vector3(0, 8, -12); 
            const cameraOffset = relativeOffset.applyMatrix4(raccoon.matrixWorld);
            camera.position.lerp(cameraOffset, 0.04);
            camera.lookAt(raccoon.position.x, raccoon.position.y + 1, raccoon.position.z);
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life--;
                p.mesh.position.add(p.vel);
                p.vel.y -= 0.02; 
                if (p.life <= 0 || p.mesh.position.y < 0) { scene.remove(p.mesh); particles.splice(i, 1); }
            }
        }

        function updateTrash() {
            trashItems.forEach(item => {
                item.position.y = item.userData.originalY + Math.sin(time * 2 + item.userData.floatOffset) * 0.1;
                item.rotation.y += item.userData.rotationSpeed;
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016; 
            if (isGameActive) {
                updateRaccoon();
                updateRaccoonDance();
                updateCamera();
                updateTrash();
                checkCollisions();
                checkRadioProximity();
                updateParticles();
                
                if (comboActive) {
                    comboTimer -= 0.016; 
                    if (comboTimer <= 0) {
                        comboActive = false;
                        combo = 0;
                        isDancing = false;
                        danceIntensity = 0;
                    }
                }
            }
            renderer.render(scene, camera);
        }

        // --- Init call is meant to be at the end, but functions are hoisted ---
        init();

        let squeakBubbleTimer = null;

        function showSqueakBubble(text) {
            const b = document.getElementById("squeak-bubble");
            b.style.background = `rgba(255, ${200 - danceIntensity * 50}, 0, 1)`; 
            if (!b) return;
            b.innerText = text || "*squeak!*";
            b.style.opacity = "1";
            b.style.transform = "translate(-50%, -70%)";
            clearTimeout(squeakBubbleTimer);
            squeakBubbleTimer = setTimeout(() => {
                b.style.opacity = "0";
                b.style.transform = "translate(-50%, -50%)";
            }, 900);
        }

        function playSqueak() {
            const now = Date.now() / 1000;
            let timeSinceLastBeat = (now - lastBeatTime) % beatInterval;
            const beatWindow = 0.15; 
            if (timeSinceLastBeat < beatWindow || timeSinceLastBeat > beatInterval - beatWindow) {
                // On beat
                combo++;
                comboActive = true;
                comboTimer = comboDuration;
                if (combo >= 10) {
                    isDancing = true;
                    danceIntensity = Math.min(maxDanceIntensity, (combo - 9) * 0.2); 
                }
                showSqueakBubble("Combo x" + combo);
            } else {
                // Off beat
                combo = 0;
                comboActive = false;
                isDancing = false;
                danceIntensity = 0;
                showSqueakBubble("*squeak!*");
            }
            squeakSound.currentTime = 0;
            squeakSound.play().catch(e=>{});
            lastSqueakTime = now;
        }

        function updateRaccoonDance() {
            if (!raccoon || !isDancing) return;
            const t = time * (danceSpeed + danceIntensity * 2);
            raccoon.children[0].position.y = 1.5 + Math.sin(t * (1 + danceIntensity)) * (0.5 + danceIntensity * 0.3);
            if (headGroup) {
                headGroup.position.y = 2.5 + Math.sin(t * 1.5) * (0.5 + danceIntensity * 0.3);
                headGroup.rotation.y = Math.sin(t * 2) * (0.5 + danceIntensity * 0.4);
                headGroup.rotation.x = Math.sin(t * 1.2) * 0.2 * danceIntensity;
            }
            if (tail) {
                tail.position.y = 1.2 + Math.sin(t * 2) * (0.5 + danceIntensity * 0.2);
                tail.rotation.y = Math.sin(t * 4) * (1.2 + danceIntensity * 0.5);
                tail.rotation.x = Math.sin(t * 3) * (0.2 + danceIntensity * 0.2);
            }
            raccoon.children.forEach(child => {
                if (child.name === 'fl' || child.name === 'br') child.rotation.x = Math.sin(t * 3) * (1 + danceIntensity);
                else if (child.name === 'fr' || child.name === 'bl') child.rotation.x = Math.cos(t * 3) * (1 + danceIntensity);
            });
        }
    </script>
</body>
</html>
